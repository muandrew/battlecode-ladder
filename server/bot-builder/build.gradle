// This is the build file we use to compile and run Battlecode players.
// We're using Gradle: https://gradle.org/

// Gradle's plugins allow it to automatically generate build scripts
// for different types of code. Here we apply the Java plugin, which provides
// all the tools needed to build player code!

// Note: this file has been modified to be "optimized" for ci builds
// see https://github.com/battlecode/battlecode-scaffold-2017/blob/master/build.gradle
// for the full copy.

apply plugin: 'java'
apply plugin: 'kotlin'
apply plugin: 'scala'

// Extra tools from battlecode.
apply plugin: 'battlecode'

// Tell gradle that we want Java 8.
sourceCompatibility = 1.8
targetCompatibility = 1.8

// We override Gradle's defaults for project directory layout.
sourceSets {
    main {
        scala.srcDirs = ["src"]
        kotlin.srcDirs = ["src"]
        output.classesDir = "$buildDir/classes"
    }

    test {
        scala.srcDirs = ["test"]
        kotlin.srcDirs = ["test"]
        output.classesDir = "$buildDir/tests"
    }
}

repositories {
    maven {
        url "http://battlecode-maven.s3-website-us-east-1.amazonaws.com/"
    }
    jcenter()
}

// The dependencies of this project.
dependencies {
    // The Battlecode engine.
    compile group: 'org.battlecode', name: 'battlecode', version: versions.battlecode

    compile "org.jetbrains.kotlin:kotlin-stdlib:$versions.kotlin"

    // Scala!
    compile group: 'org.scala-lang', name: 'scala-library', version: versions.scala
    compile group: 'org.scala-lang', name: 'scala-compiler', version: versions.scala
    compile group: 'org.scala-lang', name: 'scala-reflect', version: versions.scala
}

// Default configuration for running matches.
if (!project.hasProperty("teamA")) {
    ext.teamA = "examplefuncsplayer"
}
if (!project.hasProperty("teamB")) {
    ext.teamB = "examplefuncsplayer"
}
if (!project.hasProperty("mapsUrl") || project.property('mapsUrl').allWhitespace) {
    ext.mapsUrl = "maps"
}
if (!project.hasProperty("maps") || project.property('maps').allWhitespace) {
    ext.maps = "shrine"
}
if (!project.hasProperty("teamAUrl")) {
    ext.teamAUrl = "/"
}
if (!project.hasProperty("teamBUrl")) {
    ext.teamBUrl = "/"
}
if (!project.hasProperty("matchUrl")) {
    ext.matchUrl = "/"
}
if (!project.hasProperty("websocket")) {
    ext.websocket = "6175"
}

build.group = 'battlecode'

// Another task. This one accepts three optional parameters, or "properties",
// corresponding to the bots used by the two teams, and the map(s) used in this
// game. These properties can be set in the command line with:
// On windows:
//   `gradlew -PteamA=<team A bot> -PteamB=<team B bot> -Pmaps=<comma
//   separated list of maps>`
// On OS X and Linux:
//   `./gradlew -PteamA=<team A bot> -PteamB=<team B bot> -Pmaps=<comma
//   separated list of maps>`
task run(type: JavaExec, dependsOn: 'build') {
    description 'Runs a match without starting the client.'
    group 'battlecode'

    main = 'battlecode.server.Main'
    classpath = sourceSets.main.runtimeClasspath
    args = ['-c=-']
    jvmArgs = [
        '-Dbc.server.mode=headless',
        '-Dbc.server.debug=true',
        '-Dbc.engine.debug-methods=false',
        '-Dbc.game.team-a='+project.property('teamA'),
        '-Dbc.game.team-b='+project.property('teamB'),
        '-Dbc.game.team-a.url='+project.property('teamAUrl'),
        '-Dbc.game.team-b.url='+project.property('teamBUrl'),
        '-Dbc.game.maps='+project.property('maps'),
        '-Dbc.game.map-path='+project.property('mapsUrl'),
        '-Dbc.server.save-file='+project.property('matchUrl') + '.bc17',
        '-Dbc.server.websocket='+project.property('websocket')
    ]
}

// This task prints out all available players, in the format that the `run`
// task expects them to be given as.
task listPlayers {
    description 'Lists all available players.'
    group 'battlecode'

    doLast {
        sourceSets.main.allSource.each {
            if (it.getName().equals('RobotPlayer.java')
                || it.getName().equals('RobotPlayer.kt')
                || it.getName().equals('RobotPlayer.scala')) {
                URI base = new File(project.projectDir, 'src').toURI()
                URI full = it.toURI()
                String path = base.relativize(full).toString()
                println 'PLAYER: '+path.substring(0, path.lastIndexOf('/')).replaceAll('/', '.')
            }
        }
    }
}

// This task prints out all available maps, in the format that the `run` task
// expects them to be given as.
task listMaps {
    description 'Lists all available maps.'
    group 'battlecode'

    doLast {
        sourceSets.main.compileClasspath.each {
            if (it.toString().contains('battlecode-2017')) {
                FileCollection fc = zipTree(it)
                fc += fileTree(new File(project.projectDir, 'maps'))
                fc.each {
                    String fn = it.getName()
                    if (fn.endsWith('.map17')) {
                        println 'MAP: '+fn.substring(0, fn.indexOf('.map17'))
                    }
                }
            }
        }
    }
}

// We need to download the battlecode plugin before we can run the build script; this does that.
buildscript {
    ext.versions = [
        battlecode: '2017.+',
        kotlin: '1.0.6',
        scala: '2.11.7'
    ]

    repositories {
        maven {
            url "http://battlecode-maven.s3-website-us-east-1.amazonaws.com/"
        }
        jcenter()
    }
    dependencies {
        // Load the battlecode plugin onto the classpath.
        classpath group: 'org.battlecode', name: 'battlecode-gradle-plugin', version: versions.battlecode
        classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:$versions.kotlin"
    }
}
